<!DOCTYPE html>
<html lang="en" class="scroll-smooth">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="{{ description or 'Saramonse Beauty' }}">
    <title>{{ title }}</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Alex+Brush&family=Jost:wght@300;400;500;600&family=Cormorant+Garamond:wght@300;400;500&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/styles.css">
</head>
<body class="font-serif text-gray-800">
    <!-- Dark transparent nav over video hero -->
    {% set navTheme = "dark" %}
    {% set navId = "nav-hero" %}
    {% set navBg = "bg-transparent" %}
    {% set navExtraClasses = "transition-all duration-500 ease-in-out opacity-100 translate-y-0" %}
    {% include "navigation.njk" %}

    <!-- Compact Nav (Logo Left, Dark) - shown on scroll -->
    {% include "compact-nav.njk" %}

    <!-- Video Hero Section -->
    <div id="video-hero" class="relative w-full aspect-[21/7] overflow-hidden bg-black">
        <video
            class="absolute w-[calc(100%+10px)] object-cover object-top"
            autoplay
            muted
            loop
            playsinline
            poster="{{ videoPoster or '' }}"
        >
            <source src="{{ videoSrc or '/assets/hero-video.mp4' }}" type="video/mp4">
        </video>
        <!-- Dark overlay -->
        <div class="absolute inset-y-0 -inset-x-40 bg-gradient-to-b from-black/80 to-black/20 z-10"></div>
    </div>

    <main class="bg-white">
        {{ content | safe }}
    </main>

    {% include "footer.njk" %}

    <script>
        const mobileMenuBtns = document.querySelectorAll('.mobile-menu-btn');
        const mobileMenu = document.getElementById('mobile-menu');
        const navHero = document.getElementById('nav-hero');
        const navCompact = document.getElementById('nav-compact');
        const heroSection = document.getElementById('video-hero');

        // Circle burst mobile menu.
        // Clip-path is animated via JS-set inline transitions rather than @keyframes
        // so that Safari iOS can interpolate it correctly (Safari cannot interpolate
        // clip-path when CSS custom properties appear inside @keyframes).
        const EASE = 'cubic-bezier(0.77, 0, 0.175, 1)';

        function setClipPath(val) {
            mobileMenu.style.webkitClipPath = val;
            mobileMenu.style.clipPath = val;
        }

        function setTransition(duration) {
            const t = duration
                ? `-webkit-clip-path ${duration} ${EASE}, clip-path ${duration} ${EASE}`
                : 'none';
            mobileMenu.style.webkitTransition = t;
            mobileMenu.style.transition = t;
        }

        function openMenu(btn) {
            const rect = btn.getBoundingClientRect();
            const ox = Math.round(rect.left + rect.width / 2);
            const oy = Math.round(rect.top + rect.height / 2);

            // Make element visible before animating â€” Safari does not reliably
            // hide/show position:fixed elements with clip-path alone.
            mobileMenu.style.visibility = 'visible';

            // Snap to closed at button position without transition.
            setTransition(null);
            setClipPath(`circle(0% at ${ox}px ${oy}px)`);

            // Force reflow so the "no transition" state commits.
            mobileMenu.getBoundingClientRect(); // eslint-disable-line no-unused-expressions

            // Animate burst open.
            setTransition('0.65s');
            setClipPath(`circle(150% at ${ox}px ${oy}px)`);

            mobileMenu.classList.remove('menu-closing');
            mobileMenu.classList.add('menu-open');
            mobileMenuBtns.forEach(b => b.classList.add('menu-open'));

            // iOS Safari ignores overflow:hidden on <html>/<body>; use position:fixed.
            const sy = window.scrollY ?? window.pageYOffset;
            document.body.dataset.menuScrollY = sy;
            document.body.style.position = 'fixed';
            document.body.style.top = `-${sy}px`;
            document.body.style.width = '100%';
        }

        function closeMenu() {
            // Read the origin so the circle collapses toward the same button.
            const cp = mobileMenu.style.clipPath || mobileMenu.style.webkitClipPath || '';
            const m  = cp.match(/at\s+([\d.]+)px\s+([\d.]+)px/);
            const ox = m ? m[1] : '40';
            const oy = m ? m[2] : '40';

            mobileMenu.classList.remove('menu-open');
            mobileMenu.classList.add('menu-closing');
            mobileMenuBtns.forEach(b => b.classList.remove('menu-open'));

            // Animate burst closed.
            setTransition('0.5s');
            setClipPath(`circle(0% at ${ox}px ${oy}px)`);

            // Restore scroll (iOS-safe).
            const sy = parseInt(document.body.dataset.menuScrollY || '0', 10);
            document.body.style.position = '';
            document.body.style.top = '';
            document.body.style.width = '';
            window.scrollTo(0, sy);

            // Safari sometimes skips transitionend for clip-path; use a timeout
            // fallback (slightly longer than the 0.5s close transition).
            const closeTimer = setTimeout(() => {
                mobileMenu.classList.remove('menu-closing');
                mobileMenu.style.visibility = 'hidden';
                mobileMenu.removeEventListener('transitionend', onEnd);
                mobileMenu.removeEventListener('webkitTransitionEnd', onEnd);
            }, 600);

            function onEnd(e) {
                if (e.propertyName === 'clip-path' || e.propertyName === '-webkit-clip-path') {
                    clearTimeout(closeTimer);
                    mobileMenu.classList.remove('menu-closing');
                    mobileMenu.style.visibility = 'hidden';
                    mobileMenu.removeEventListener('transitionend', onEnd);
                    mobileMenu.removeEventListener('webkitTransitionEnd', onEnd);
                }
            }
            mobileMenu.addEventListener('transitionend', onEnd);
            mobileMenu.addEventListener('webkitTransitionEnd', onEnd);
        }

        mobileMenuBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                if (mobileMenu.classList.contains('menu-open')) {
                    closeMenu();
                } else {
                    openMenu(btn);
                }
            });
        });

        mobileMenu.querySelectorAll('a').forEach(link => {
            link.addEventListener('click', closeMenu);
        });

        // Switch between nav layouts on scroll
        window.addEventListener('scroll', () => {
            const heroHeight = heroSection.offsetHeight;
            const scrollY = window.scrollY;
            const shouldBeCompact = scrollY > heroHeight - 100;

            if (shouldBeCompact) {
                navHero.classList.remove('opacity-100', 'translate-y-0');
                navHero.classList.add('opacity-0', '-translate-y-full', 'pointer-events-none');

                navCompact.classList.remove('opacity-0', '-translate-y-full', 'pointer-events-none');
                navCompact.classList.add('opacity-100', 'translate-y-0');
            } else {
                navCompact.classList.remove('opacity-100', 'translate-y-0');
                navCompact.classList.add('opacity-0', '-translate-y-full', 'pointer-events-none');

                navHero.classList.remove('opacity-0', '-translate-y-full', 'pointer-events-none');
                navHero.classList.add('opacity-100', 'translate-y-0');
            }
        });
    </script>
</body>
</html>
